using System.Threading.Channels;
using Hekaton.Core.Collectors;
using Hekaton.Core.Renderers;
using Spectre.Console;
using TDigest;

namespace Hekaton.Core;

/// <summary>
/// This class is responsible for collecting the StepEvents as metrics.  These
/// metrics are persisted using a plugin mechanism that defines where to store
/// the results.
/// </summary>
public class MetricsCollector {
  private readonly ICollector? _collector;
  private readonly IRenderer? _renderer;
  private readonly Dictionary<string, AbstractTDigest> _stats;

  /// <summary>
  /// Creates an instance configured with the specified metrics collector and
  /// renderer.
  /// </summary>
  /// <param name="collector">The collector to use.</param>
  /// <param name="renderer">The renderer to use.</param>
  public MetricsCollector(Collector collector, Renderer renderer) {
    _collector = collector switch {
      Collector.InMemory => new InMemoryCollector(),
      Collector.Postgres => throw new NotImplementedException(),
      Collector.SqlLite => throw new NotImplementedException(),
      Collector.Dynamo => throw new NotImplementedException(),
      _ => throw new NotImplementedException(),
    };

    _renderer = renderer switch {
      Renderer.Console => new ConsoleRenderer(),
      Renderer.Html => throw new NotImplementedException(),
      Renderer.Json => throw new NotImplementedException(),
      Renderer.Markdown => throw new NotImplementedException(),
      _ => throw new NotImplementedException()
    };

    _stats = new();
  }

  /// <summary>
  /// Starts the metrics collector.
  /// </summary>
  /// <param name="reader">
  /// The channel reader which provides the source of events generated by the
  /// individual scenario runtime instances.
  /// </param>
  public async Task StartAsync(ChannelReader<ScenarioEvent> reader) {
    while (await reader.WaitToReadAsync()) {
      if (reader.TryRead(out var scenarioEvent)) {
        Action fn = (scenarioEvent as object) switch {
          ScenarioErrorEvent error => () => HandleError(error),
          ScenarioStepEvent step => () => HandleStep(step),
          ScenarioStartEvent count => () => HandleScenarioStart(count),
          ScenarioCompletedEvent completion => () => HandleScenarioCompleted(completion),
          _ => () => {}
        };

        fn();
      }
    }
  }

  /// <summary>
  /// Handles the scenario completion event.
  /// </summary>
  private void HandleScenarioCompleted(ScenarioCompletedEvent completion) {
    AnsiConsole.MarkupLineInterpolated($"[green]Scenario Completed: {completion.ScenarioName} {completion.Identifier}[/]");
  }

  /// <summary>
  /// Handles the scenario start event.
  /// </summary>
  /// <param name="start">The start event of the scenario.</param>
  private void HandleScenarioStart(ScenarioStartEvent start) {
    AnsiConsole.MarkupLineInterpolated($"[blue]Scenario Started: {start.ScenarioName} {start.Identifier}[/]");
  }

  /// <summary>
  /// For each step that executes, we want to accumulate statistics to calculate
  /// the mean, p90, and so on.  Additionally, we want to track completion
  /// percentage.
  /// </summary>
  /// <param name="step">
  /// The step event which identifies the scenario and step which completed
  /// including the timing.
  /// </param>
  private void HandleStep(ScenarioStepEvent step) {
    var key = step.Key;

    if (!_stats.ContainsKey(key)) {
      // See notes here: https://github.com/Cyral/t-digest-csharp/blob/main/TDigest/MergingDigest.cs#L155C37-L155C46
      _stats[key] = new MergingDigest(100, 10);
    }

    _stats[key].Add(step.Timing.TotalMilliseconds);
  }

  /// <summary>
  /// For each step that fails, we want to accumulate the errors.
  /// </summary>
  /// <param name="error">
  /// The event which encapsulates the error.
  /// </param>
  private void HandleError(ScenarioErrorEvent error) {

  }
}