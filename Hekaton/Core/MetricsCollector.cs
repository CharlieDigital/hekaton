using System.Threading.Channels;
using Hekaton.Core.Collectors;
using Hekaton.Core.Renderers;
using TDigest;

namespace Hekaton.Core;

/// <summary>
/// This class is responsible for collecting the StepEvents as metrics.  These
/// metrics are persisted using a plugin mechanism that defines where to store
/// the results.
/// </summary>
public class MetricsCollector {
  private readonly Test _test;
  private readonly ICollector? _collector;
  private readonly IRenderer? _renderer;
  private readonly ProgressRenderer _progress;
  private readonly Dictionary<string, AbstractTDigest> _stats;

  /// <summary>
  /// Creates an instance configured with the specified metrics collector and
  /// renderer.
  /// </summary>
  /// <param name="test">The test definition.</param>
  /// <param name="collector">The collector to use.</param>
  /// <param name="renderer">The renderer to use.</param>
  public MetricsCollector(Test test, Collector collector, Renderer renderer) {
    _test = test;

    _collector = collector switch {
      Collector.InMemory => new InMemoryCollector(),
      Collector.Postgres => throw new NotImplementedException(),
      Collector.SqlLite => throw new NotImplementedException(),
      Collector.Dynamo => throw new NotImplementedException(),
      _ => throw new NotImplementedException(),
    };

    _renderer = renderer switch {
      Renderer.Console => new ConsoleRenderer(),
      Renderer.Html => throw new NotImplementedException(),
      Renderer.Json => throw new NotImplementedException(),
      Renderer.Markdown => throw new NotImplementedException(),
      _ => throw new NotImplementedException()
    };

    _progress = new ProgressRenderer(_test);

    _stats = new();
  }

  /// <summary>
  /// Starts the metrics collector.
  /// </summary>
  /// <param name="reader">
  /// The channel reader which provides the source of events generated by the
  /// individual scenario runtime instances.
  /// </param>
  public async Task StartAsync(ChannelReader<ScenarioEvent> reader) {
    Task? progress = null;

    while (await reader.WaitToReadAsync()) {
      if (reader.TryRead(out var scenarioEvent)) {
        if (!_progress.Started) {
          progress = _progress.StartAsync();
        }

        Func<Task> fn = (scenarioEvent as object) switch {
          ScenarioErrorEvent error => () => HandleErrorAsync(error),
          ScenarioStepEvent step => () => HandleStepAsync(step),
          ScenarioStartEvent count => async () => await Task.CompletedTask,
          ScenarioCompletedEvent completion => () => HandleScenarioCompletedAsync(completion),
          _ => async () => await Task.CompletedTask
        };

        await fn();
      }
    }

    if (progress != null) {
      _progress.Stop();
      await progress;
    }
  }

 /// <summary>
  /// For each step that executes, we want to accumulate statistics to calculate
  /// the mean, p90, and so on.  Additionally, we want to track completion
  /// percentage.
  /// </summary>
  /// <param name="step">
  /// The step event which identifies the scenario and step which completed
  /// including the timing.
  /// </param>
  private async Task HandleStepAsync(ScenarioStepEvent step) {
    var key = step.Key;

    if (!_stats.ContainsKey(key)) {
      // See notes here: https://github.com/Cyral/t-digest-csharp/blob/main/TDigest/MergingDigest.cs#L155C37-L155C46
      _stats[key] = new MergingDigest(100, 10);
    }

    _stats[key].Add(step.Timing.TotalMilliseconds);

    await _progress.UpdateStepAsync(
      step.ScenarioName,
      step.StepName,
      _stats[key].Quantile(.50),
      _stats[key].Quantile(.90),
      _stats[key].Quantile(.95),
      _stats[key].GetMin(),
      _stats[key].GetMax()
    );

    // TODO: Push to collector as well.
  }

  /// <summary>
  /// Handles the scenario completion event.
  /// </summary>
  private async Task HandleScenarioCompletedAsync(ScenarioCompletedEvent completion) {
    await _progress.UpdateScenarioAsync(completion.ScenarioName);

    // TODO: Push to collector as well.
  }

  /// <summary>
  /// For each step that fails, we want to accumulate the errors.
  /// </summary>
  /// <param name="error">
  /// The event which encapsulates the error.
  /// </param>
  private async Task HandleErrorAsync(ScenarioErrorEvent error) {
    await Task.CompletedTask;

    // TODO: Push to collector as well.
  }
}