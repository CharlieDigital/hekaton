using System.Threading.Channels;
using Hekaton.Core.Collectors;
using Hekaton.Core.Renderers;
using Hekaton.Models;

namespace Hekaton.Core;

/// <summary>
/// This class is responsible for collecting the StepEvents as metrics.  These
/// metrics are persisted using a plugin mechanism that defines where to store
/// the results.
/// </summary>
public class MetricsCollector {
  private readonly ICollector? _collector;
  private readonly IRenderer? _renderer;

  /// <summary>
  /// Creates an instance configured with the specified metrics collector and
  /// renderer.
  /// </summary>
  /// <param name="collector">The collector to use.</param>
  /// <param name="renderer">The renderer to use.</param>
  public MetricsCollector(Collector collector, Renderer renderer) {
    _collector = collector switch {
      Collector.InMemory => new InMemoryCollector(),
      Collector.Postgres => throw new NotImplementedException(),
      Collector.SqlLite => throw new NotImplementedException(),
      Collector.Dynamo => throw new NotImplementedException(),
      _ => throw new NotImplementedException(),
    };

    _renderer = renderer switch {
      Renderer.Console => new ConsoleRenderer(),
      Renderer.Html => throw new NotImplementedException(),
      Renderer.Json => throw new NotImplementedException(),
      Renderer.Markdown => throw new NotImplementedException(),
      _ => throw new NotImplementedException()
    };
  }

  /// <summary>
  /// Starts the metrics collector.
  /// </summary>
  /// <param name="reader">
  /// The channel reader which provides the source of events generated by the
  /// individual scenario runtime instances.
  /// </param>
  public async Task StartAsync(ChannelReader<ScenarioEvent> reader) {
    while (await reader.WaitToReadAsync()) {
      if (reader.TryRead(out var scenarioEvent)) {
        Action fn = (scenarioEvent as object) switch {
          ScenarioErrorEvent error => () => HandleError(error),
          ScenarioStepEvent step => () => HandleStep(step),
          ScenarioStartEvent count => () => HandleScenarioStart(count),
          ScenarioEvent scenario => () => HandleScenario(scenario),
          _ => () => {}
        };

        fn();
      }
    }
  }

  private void HandleScenario(ScenarioEvent scenario) {

  }

  private void HandleScenarioStart(ScenarioStartEvent start) {

  }

  private void HandleStep(ScenarioStepEvent step) {

  }

  private void HandleError(ScenarioErrorEvent error) {

  }
}